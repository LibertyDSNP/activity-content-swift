"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireValidActivityContentProfile = exports.requireValidActivityContentNote = exports.requireGetSupportedContentAttachments = exports.isActivityContentProfileType = exports.requireIsActivityContentProfileType = exports.isActivityContentNoteType = exports.requireIsActivityContentNoteType = exports.requireToActivityContentAttachment = exports.isDSNPUserURI = void 0;
const validation_1 = require("./utilities/validation");
const errors_1 = require("./errors");
/**
 * Regex for ISO 8601 / XML Schema Dates
 * - T separation
 * - Required Time
 * - Supports fractional seconds
 * - Z or hour minute offset
 */
const ISO8601_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d{1,})?(Z|[+-][01][0-9]:[0-5][0-9])?$/;
const HREF_REGEX = /^https?:\/\/.+/;
const DURATION_REGEX = /^-?P(([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9]+)?S)?)?)+$/;
const HASH_REGEX = /^0x[0-9A-Fa-f]{64}$/;
const SUPPORTED_ALGORITHMS = ["keccak256"];
const SUPPORTED_AUDIO_MEDIA_TYPES = ["audio/mpeg", "audio/ogg", "audio/webm"];
const SUPPORTED_IMAGE_MEDIA_TYPES = [
    "image/jpeg",
    "image/png",
    "image/svg+xml",
    "image/webp",
    "image/gif",
];
const SUPPORTED_VIDEO_MEDIA_TYPES = [
    "video/mpeg",
    "video/ogg",
    "video/webm",
    "video/H256",
    "video/mp4",
];
/**
 * isDSNPUserURI validates a given object as a DSNPUserURI.
 *
 * @param uri - The object to validate
 * @returns True of false depending on whether the string is a valid DSNPUserURI
 */
const isDSNPUserURI = (uri) => {
    if (!(0, validation_1.isString)(uri))
        return false;
    return uri.match(/^dsnp:\/\/[1-9][0-9]{0,19}$/) !== null;
};
exports.isDSNPUserURI = isDSNPUserURI;
const invalidRecordMessage = (extra) => {
    return `${extra || "object"} is not a record type`;
};
const requireToString = (obj, name) => {
    if (!(0, validation_1.isString)(obj))
        throw new errors_1.InvalidActivityContentError(`${name} is not a string`);
    return obj;
};
const requireToArray = (obj, name) => {
    if (!Array.isArray(obj))
        throw new errors_1.InvalidActivityContentError(`${name} is not an Array`);
    return obj;
};
const isValidHrefField = (obj) => obj.match(HREF_REGEX) !== null;
const isValidPublishedField = (obj) => obj.match(ISO8601_REGEX) !== null;
const isValidDurationField = (obj) => obj.match(DURATION_REGEX) !== null;
const hasAtLeastOneSupportedAudioMediaType = (obj) => {
    for (const audioLink of obj) {
        if (SUPPORTED_AUDIO_MEDIA_TYPES.includes(audioLink["mediaType"]))
            return true;
    }
    return false;
};
const hasAtLeastOneSupportedImageMediaType = (obj) => {
    for (const imageLink of obj) {
        if (SUPPORTED_IMAGE_MEDIA_TYPES.includes(imageLink["mediaType"]))
            return true;
    }
    return false;
};
const hasAtLeastOneSupportedVideoMediaType = (obj) => {
    for (const videoLink of obj) {
        if (SUPPORTED_VIDEO_MEDIA_TYPES.includes(videoLink["mediaType"]))
            return true;
    }
    return false;
};
const hasAtLeastOneSupportedHashAlgorithm = (obj) => {
    for (const hash of obj) {
        if (hash["algorithm"] === "keccak256" &&
            (0, validation_1.isString)(hash["value"]) &&
            hash["value"].match(HASH_REGEX))
            return true;
    }
    return false;
};
const toActivityContentAttachment = (obj) => {
    try {
        return (0, exports.requireToActivityContentAttachment)(obj);
    }
    catch (e) {
        if (e instanceof errors_1.InvalidActivityContentError) {
            console.error(e.toString());
            return undefined;
        }
        throw e;
    }
};
const requireValidDimensions = (obj, name) => {
    if (obj["height"] && !(0, validation_1.isNumber)(obj["height"]))
        throw new errors_1.InvalidActivityContentError(`${name} height is invalid`);
    if (obj["width"] && !(0, validation_1.isNumber)(obj["width"]))
        throw new errors_1.InvalidActivityContentError(`${name} width is invalid`);
    return true;
};
const requireValidDuration = (obj, contentType) => {
    const duration = requireToString(obj["duration"], `${contentType} duration`);
    if (duration.length < 3 || !isValidDurationField(duration))
        throw new errors_1.InvalidActivityContentError(`${contentType} duration is invalid`);
    return true;
};
/**
 * requireActivityContentAttachment validates an unknown object and returns it
 * as an ActivityContentAttachment type if valid, and throws an error if not.
 *
 * @param obj - the object to convert
 */
const requireToActivityContentAttachment = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentAttachment")); // this check is required for type checking to work
    if (!obj["type"])
        throw new errors_1.InvalidActivityContentError("ActivityContentAttachment type is invalid");
    switch (obj["type"]) {
        case "Image":
            return requireToActivityContentImage(obj);
        case "Audio":
            return requireToActivityContentAudio(obj);
        case "Link":
            return requireToActivityContentLink(obj);
        case "Video":
            return requireToActivityContentVideo(obj);
        default:
            throw new errors_1.InvalidActivityContentError("unknown ActivityContentAttachment type: " + obj["type"]);
    }
};
exports.requireToActivityContentAttachment = requireToActivityContentAttachment;
const requireIsMediaContentLink = (obj, name) => {
    if (obj["type"] !== "Link")
        throw new errors_1.InvalidActivityContentError(`${name} type is not 'Link'`);
    requireToString(obj["mediaType"], `${name} mediaType`);
    requireToString(obj["href"], `${name} href`);
    if (!(0, validation_1.isArrayOfType)(obj["hash"], requireIsActivityContentHash))
        throw new errors_1.InvalidActivityContentError(`${name} hash is invalid`);
    if (!hasAtLeastOneSupportedHashAlgorithm(obj["hash"]))
        throw new errors_1.InvalidActivityContentError("ActivityContent hash algorithms must contain at least one of: " +
            SUPPORTED_ALGORITHMS.join(","));
    return true;
};
const requireIsActivityContentAudioLink = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentAudioLink"));
    requireIsMediaContentLink(obj, "ActivityContentAudioLink");
    return true;
};
const requireIsActivityContentImageLink = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentImageLink"));
    requireIsMediaContentLink(obj, "ActivityContentImageLink");
    requireValidDimensions(obj, "ActivityContentImageLink");
    return true;
};
const requireIsActivityContentVideoLink = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentVideoLink"));
    requireIsMediaContentLink(obj, "ActivityContentVideoLink");
    requireValidDimensions(obj, "ActivityContentVideoLink");
    return true;
};
const requireToActivityContentLink = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentVideoLink"));
    if (obj["type"] !== "Link")
        throw new errors_1.InvalidActivityContentError("ActivityContentLink type is not 'Link'");
    const href = requireToString(obj["href"], "ActivityContentLink href");
    if (!isValidHrefField(href))
        throw new errors_1.InvalidActivityContentError("ActivityContentLink href is invalid");
    if (obj["name"])
        requireToString(obj["name"], "ActivityContentLink name");
    return { type: "Link", href: "", ...obj };
};
const requireIsActivityContentHash = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentHash"));
    const hashVal = requireToString(obj["value"], "ActivityContentHash value field");
    if (!hashVal.match(HASH_REGEX))
        throw new errors_1.InvalidActivityContentError("ActivityContentHash value is invalid");
    requireToString(obj["algorithm"], "ActivityContentHash algorithm");
    return true;
};
const requireIsActivityContentLocation = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentLocation"));
    if (obj["type"] !== "Place")
        throw new errors_1.InvalidActivityContentError("ActivityContentLocation type is not 'Place'");
    if (obj["name"])
        requireToString(obj["name"], "ActivityContentLocation name");
    if (obj["units"])
        requireToString(obj["units"], "ActivityContentLocation units");
    ["accuracy", "altitude", "latitude", "longitude", "radius"].forEach((dimension) => {
        if (obj[dimension] && !(0, validation_1.isNumber)(obj[dimension]))
            throw new errors_1.InvalidActivityContentError(`ActivityContentLocation ${dimension} is not a number`);
    });
    return true;
};
const requireIsActivityContentTag = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentTag"));
    if (obj["type"] === "Mention") {
        return requireIsActivityContentMention(obj);
    }
    return requireIsActivityContentHashtag(obj);
};
const requireIsActivityContentHashtag = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentHashtag")); // this check is required for type checking to work
    requireToString(obj["name"], "ActivityContentHashtag name");
    return true;
};
const requireIsActivityContentMention = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentMention")); // this check is required for type checking to work
    if (!(0, exports.isDSNPUserURI)(obj["id"]))
        throw new errors_1.InvalidActivityContentError("ActivityContentMention id is not a valid DSNPUserURI");
    if (obj["name"])
        requireToString(obj["name"], "ActivityContentMention name");
    return true;
};
/**
 * requireToActivityContentAudio validates then converts an unknown object type to an ActivityContentAudio
 * in a type safe way.  It throws an error if the object is not valid.
 *
 * @param obj - the object to convert
 */
const requireToActivityContentAudio = (obj) => {
    const objectName = "ActivityContentAudio";
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage(objectName)); // this check is required for type checking to work
    if (obj["name"])
        requireToString(obj["name"], objectName + " name");
    if (obj["duration"])
        requireValidDuration(obj, objectName);
    if (obj["type"] !== "Audio")
        throw new errors_1.InvalidActivityContentError(`${objectName} type is not "Audio"`);
    if (!(0, validation_1.isArrayOfType)(obj["url"], requireIsActivityContentAudioLink))
        throw new errors_1.InvalidActivityContentError(`invalid ${objectName}Link`);
    if (!hasAtLeastOneSupportedAudioMediaType(obj["url"]))
        throw new errors_1.InvalidActivityContentError(objectName + " has no supported media types");
    return { type: "Audio", url: [], ...obj };
};
/**
 * requireToActivityContentImage validates then converts an unknown object type to an ActivityContentImage
 * in a type safe way. It throws an error if the object is not valid.
 *
 * @param obj - the object to convert
 */
const requireToActivityContentImage = (obj) => {
    const objectName = "ActivityContentImage";
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage(objectName)); // this check is required for type checking to work
    if (obj["name"])
        requireToString(obj["name"], objectName + " name");
    if (obj["type"] !== "Image")
        throw new errors_1.InvalidActivityContentError(`${objectName} type is not "Image"`);
    if (!(0, validation_1.isArrayOfType)(obj["url"], requireIsActivityContentImageLink))
        throw new errors_1.InvalidActivityContentError(`invalid ${objectName}Link`);
    if (!hasAtLeastOneSupportedImageMediaType(obj["url"]))
        throw new errors_1.InvalidActivityContentError(`${objectName} has no supported media types`);
    return { type: "Image", url: [], ...obj };
};
/**
 * requireToActivityContentVideo validates then converts an unknown object type to an ActivityContentVideo
 * in a type safe way.  It throws an error if the object is not valid.
 *
 * @param obj - the object to convert
 */
const requireToActivityContentVideo = (obj) => {
    const objectName = "ActivityContentVideo";
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage(objectName)); // this check is required for type checking to work
    if (obj["name"])
        requireToString(obj["name"], objectName + " name");
    if (obj["duration"])
        requireValidDuration(obj, objectName);
    if (obj["type"] !== "Video")
        throw new errors_1.InvalidActivityContentError("type is not 'Video'");
    if (!(0, validation_1.isArrayOfType)(obj["url"], requireIsActivityContentVideoLink))
        throw new errors_1.InvalidActivityContentError(`invalid ${objectName}Link`);
    if (!hasAtLeastOneSupportedVideoMediaType(obj["url"]))
        throw new errors_1.InvalidActivityContentError(`${objectName} has no supported media types`);
    return { type: "Video", url: [], ...obj };
};
const requireIsActivityContentBaseType = (obj, typeName) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError("ActivityContentNote"); // this check is required for type checking to work
    if (obj["@context"] !== "https://www.w3.org/ns/activitystreams")
        throw new errors_1.InvalidActivityContentError(`invalid ActivityContent${typeName} @context`);
    if (obj["type"] !== typeName)
        throw new errors_1.InvalidActivityContentError(`invalid ActivityContent${typeName} type`);
    if (obj["name"])
        requireToString(obj["name"], `ActivityContent${typeName} name`);
    if (obj["published"])
        requireToString(obj["published"], `ActivityContent${typeName} published`);
    if (obj["tag"] && !(0, validation_1.isRecord)(obj["tag"]))
        requireToArray(obj["tag"], `ActivityContent${typeName} tag`);
    if (obj["location"] && !(0, validation_1.isRecord)(obj["location"]))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage(`ActivityContent${typeName} location`));
    return true;
};
/**
 * requireActivityContentNoteType() is a type check function for ActivityContentNote
 * objects. Note that this function only checks that the given object meets the
 * first-level type definition of an ActivityContentNote. It **does not** perform
 * deeper type validations or any logic
 * validations, such as checking the format of string fields or checking that
 * required attachments each include at least one supported format.
 *
 * @param obj - The object to check
 * @returns true if the object is an ActivityContentNote, otherwise throws an Error.
 * @throws InvalidActivityContentError if type checks fail.
 */
const requireIsActivityContentNoteType = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError("ActivityContentNote"); // this check is required for type checking to work
    requireIsActivityContentBaseType(obj, "Note");
    if (obj["mediaType"] !== "text/plain")
        throw new errors_1.InvalidActivityContentError("invalid ActivityContentNote mediaType");
    if (obj["attachment"])
        requireToArray(obj["attachment"], "ActivityContentNote attachment");
    return true;
};
exports.requireIsActivityContentNoteType = requireIsActivityContentNoteType;
/**
 * isActivityContentNoteType is a non-throwing version of `requireIsActivityContentNoteType`
 * Performs the same checks but catches InvalidActivityContentError and returns false instead.
 *
 * @param obj - The object to check
 * @returns a boolean - indicating if the object is an ActivityContentNote
 */
const isActivityContentNoteType = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        return false;
    try {
        (0, exports.requireIsActivityContentNoteType)(obj);
    }
    catch (e) {
        if (e instanceof errors_1.InvalidActivityContentError)
            return false;
        throw e;
    }
    return true;
};
exports.isActivityContentNoteType = isActivityContentNoteType;
/**
 * requireIsActivityContentProfileType() is a type check function for
 * ActivityContentProfile objects. Note that this function only checks that the
 * given object meets the first-level type definition of an ActivityContentProfile. It
 * does not** perform deeper type validations or any logic validations, such as checking the format of
 * string fields or checking that the icon field includes at least one supported
 * image format.
 *
 * @param obj - The object to check
 * @returns true if the object is an ActivityContentProfile,otherwise throws an Error
 * @throws InvalidActivityContentError if type checks fail.
 */
const requireIsActivityContentProfileType = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        throw new errors_1.InvalidActivityContentError(invalidRecordMessage("ActivityContentProfile"));
    requireIsActivityContentBaseType(obj, "Profile");
    if (obj["summary"])
        requireToString(obj["summary"], "ActivityContentProfile summary");
    if (obj["icon"] &&
        !(0, validation_1.isArrayOfType)(obj["icon"], requireIsActivityContentImageLink))
        throw new errors_1.InvalidActivityContentError("ActivityContentProfile icon is invalid");
    if (obj["attachment"])
        requireToArray(obj["attachment"], "ActivityContentProfile attachment");
    return true;
};
exports.requireIsActivityContentProfileType = requireIsActivityContentProfileType;
/**
 * isActivityContentProfileType is a non-throwing version of `requireIsActivityContentProfileType`.
 * Performs the same checks but catches InvalidActivityContentError and returns false instead.
 *
 * @param obj - The object to check
 * @returns a boolean - indicating if the object is an ActivityContentProfile
 */
const isActivityContentProfileType = (obj) => {
    if (!(0, validation_1.isRecord)(obj))
        return false;
    try {
        (0, exports.requireIsActivityContentProfileType)(obj);
    }
    catch (e) {
        if (e instanceof errors_1.InvalidActivityContentError)
            return false;
        throw e;
    }
    return true;
};
exports.isActivityContentProfileType = isActivityContentProfileType;
/**
 * requireGetSupportedContentAttachments iterates over the provided list and returns
 * the valid+supported attachments. If the passed in obj is empty, returns an empty array.
 * If there are attachments but none of them are valid+supported, it throws an error.
 * Attachments MUST first pass a type check to be considered valid at all.
 *
 * @param obj - an array of unknown object types to check for validity
 * @returns an array of all valid ActivityContentAttachments
 * @throws InvalidActivityContentError if there are no valid attachments with
 * supported Link attachments.
 *
 * Examples:
 * 1. One Image attachment with one URL that points to a TIFF file throws an error.
 * 2. One Image attachment with two URLs, one that is a TIFF and the other is JPG,
 *    does not throw.
 * 3. One Image attachment with two URLs, both are JPG, but one has a malformed
 *    hash of 0xdeadbeef (it's too short), throws an error due to failing
 *    the type check.
 * 4. Two Image attachments, the one from #2 and the one from #3, does NOT throw and
 *    returns just #2.
 */
const requireGetSupportedContentAttachments = (obj) => {
    if (!obj.length)
        return [];
    const validTypeAttachments = obj.filter((attachment) => {
        return !!toActivityContentAttachment(attachment);
    });
    if (!validTypeAttachments.length) {
        for (const attachment of obj) {
            (0, exports.requireToActivityContentAttachment)(attachment);
        }
    }
    return validTypeAttachments;
};
exports.requireGetSupportedContentAttachments = requireGetSupportedContentAttachments;
/**
 * requireValidActivityContentNote() validates that a given object meets all
 * necessary specification requirements for an ActivityContentNote object,
 * include string field formats and other logical validations. Note that this
 * function **does not** attempt to fetch any attachments to validate that their
 * hashes are correct.
 *
 * @param obj - The object to check
 * @returns true if valid
 * @throws InvalidActivityContentError if not valid, with a message
 */
const requireValidActivityContentNote = (obj) => {
    if ((0, exports.requireIsActivityContentNoteType)(obj)) {
        if (obj["tag"])
            requireIsActivityContentTag(obj["tag"]);
        if (obj["published"] && !isValidPublishedField(obj["published"]))
            throw new errors_1.InvalidActivityContentError("ActivityContentNote published is invalid");
        if (obj["attachment"]) {
            const attachments = requireToArray(obj["attachment"], "ActivityContentNote attachment");
            (0, exports.requireGetSupportedContentAttachments)(attachments);
        }
        if (obj["location"])
            requireIsActivityContentLocation(obj["location"]);
    }
    else {
        throw new errors_1.InvalidActivityContentError("ActivityContentNote is invalid for an unknown reason");
    }
    return true;
};
exports.requireValidActivityContentNote = requireValidActivityContentNote;
/**
 * requireValidActivityContentProfile() validates that a given object meets all
 * necessary specification requirements for an ActivityContentProfile object,
 * include string field formats and other logical validations. Note that this
 * function **does not** attempt to fetch any icons to validate that their
 * hashes are correct.
 *
 * @param obj - The object to check
 * @returns true if valid.
 * @throws InvalidActivityContentError if not valid, with a message
 */
const requireValidActivityContentProfile = (obj) => {
    if ((0, exports.requireIsActivityContentProfileType)(obj)) {
        if (obj["tag"] && !(0, validation_1.isArrayOfType)(obj["tag"], requireIsActivityContentTag))
            requireIsActivityContentTag(obj["tag"]);
        if (obj["published"] && !isValidPublishedField(obj["published"]))
            throw new errors_1.InvalidActivityContentError("ActivityContentProfile published is invalid");
        if (obj["icon"]) {
            for (const icon of obj["icon"]) {
                requireToActivityContentLink(icon);
            }
        }
        if (obj["location"])
            requireIsActivityContentLocation(obj["location"]);
    }
    else {
        throw new errors_1.InvalidActivityContentError("ActivityContentProfile is invalid for an unknown reason");
    }
    return true;
};
exports.requireValidActivityContentProfile = requireValidActivityContentProfile;
